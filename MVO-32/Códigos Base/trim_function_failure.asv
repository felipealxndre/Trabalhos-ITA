function [f, X, U, Y] = trim_function_failure(x, trim_par)
% x = [ alpha_deg; delta_c; i_t_deg ]
% Hipóteses no equilíbrio (L3 Ex. 2):
%   - V e h fixados em trim_par
%   - Voo reto e nivelado: gamma = 0  =>  theta = alpha
%   - Simetria propulsiva: delta1 = delta2 = delta_c
%   - Superfícies neutras no trim: delta_e = delta_a = delta_r = 0
%   - Sem acoplamento lateral no trim: beta = phi = p = r = 0, psi livre

% Desempacota incógnitas
alpha_deg = x(1);
delta1   = x(2);  
i_t_deg   = x(3);
delta_a_deg = x(4);
delta_r_deg = x(5);

% Impõe theta = alpha (gamma = 0)
theta_deg = alpha_deg;

% Monta estado: X = [V, alpha, q, theta, h, x, beta, phi, p, r, psi, y]^T
X = [
    trim_par.V;   % V [m/s]
    alpha_deg;    % alpha [deg]
    0;            % q [deg/s]
    theta_deg;    % theta [deg]
    trim_par.h;   % h [m]
    0;            % x [m]
    0;            % beta [deg]
    0;            % phi [deg]
    0;            % p [deg/s]
    0;            % r [deg/s]
    0;            % psi [deg]
    0             % y [m]
];

% Controles: U = [delta1, delta2, i_t, delta_e, delta_a, delta_r]^T
delta2 = 0.15;
delta_e_deg = 0;

U = [
    delta1;
    delta2;
    i_t_deg;
    delta_e_deg;
    delta_a_deg;
    delta_r_deg
];

% Dinâmica completa (a função dynamics deve devolver Xdot e Y)
% Y = [ gamma, T1, T2, Mach, CD, CL, Cm, CY, Cl, Cn, rho, qbar ]^T
[Xdot, Y] = dynamics(0, X, U);

% Resíduos de trim (3 equações, 3 incógnitas)
%   Vdot = 0
%   alphadot = 0
%   qdot = 0
f = [
    Xdot(1);   % Vdot
    Xdot(2);   % alphadot [deg/s]
    Xdot(3)   
];

% Retornos auxiliares (X, U, Y) são úteis para inspecionar trim pós-solve
end
